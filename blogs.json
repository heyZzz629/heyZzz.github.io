[
  {
    "title": "t1761980556cQGsRPUwgwzCtEOr.md",
    "content": "# 题解：P14358 [CSP-J 2025] 座位 / seat（民间数据）\nposted on 2025-11-01 07:02:36 | under  | [source](https://www.luogu.com.cn/blog/_post/1074919)\n\n## 前言\n\n作者是 xxs，考不了 CSP。\n\n## 做法\n\n照题意模拟即可。\n\n就是将所有人的成绩和序号放在一个结构体中，再排序。\n\n再求出第 $i$ 行第 $j$ 列是名次为几的人即可。\n\n如下图：\n|||||\n|:-:|:-:|:-:|:-:|\n|1  |8  |9  |16 |\n|2  |7  |10 |15 |\n|3  |6  |11 |14 |\n|4  |5  |12 |13 |\n\n用 dfs 跑一遍，再在图中找序号为 $1$ 的名次，输出行和列。\n\n## 代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,d[15][15],tot,x;//d 序号矩阵，tot 当前序号，x 编号为 1 的数排好序之后的位置。\nstruct stu{int x,id;}a[105];\nbool cmp(stu x,stu y){return x.x>y.x;};\nvoid dfs(int x,int y){ //dfs 求出序号矩阵。\n    if(x>n||y>m||x<1||y<1) return;\n    d[x][y]=++tot;\n    if(y&1){\n        if(x<n) dfs(x+1,y);\n        else dfs(x,y+1);\n    }else{\n        if(x>1) dfs(x-1,y);\n        else dfs(x,y+1);\n    }\n}signed main(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n        cin>>a[(i-1)*m+j].x,a[(i-1)*m+j].id=(i-1)*m+j;//输入\n    sort(a+1,a+n*m+1,cmp),dfs(1,1);\n    for(int i=1;i<=n*m;i++) if(a[i].id==1) x=i;//找 x\n    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\n        if(d[i][j]==x) cout<<j<<' '<<i,exit(0);//输出\n}\n```\n"
  },
  {
    "title": "t1761910217FZwpGs1a-jfNIu5M.md",
    "content": "# CSP 考场易错点\nposted on 2025-10-31 11:30:17 | under  | [source](https://www.luogu.com.cn/blog/_post/1074450)\n\n## UB（未定义行为）\n\n未定义行为就是你的代码出现了语言标准没有预料到的代码时，你的代码就会出现一些奇怪的错。\n\n有时你的评测是对的，而这种错误会在 CCF ~~垃圾~~的评测环境中暴露出来，没注意到就会爆零。\n\n### printf\n\n你**一定**要看好你输出的和 `printf` 中的类型是否一样，不然程序会错。\n\n### 有符号整数溢出也是未定义行为。\n\n### 返回值非 void 函数一定要有返回！\n\n错误示范：\n\n```cpp\nint x(int a){cout<<a;}\n```\n\n正确示范：\n\n```cpp\nint x(int a){cout<<a; return 1；}\n```\n\n### 数据结构 RE\n\nvector 下标越界。\n\nvector、queue、deque、stack 等为空时进行 pop。\n\n### 其它\n\nint,long long 除以 $0$ 或模 $0$ 也是未定义行为。\n\n## 文件读写\n\n~~都是可以进迷惑行为大赏的。~~\n\nfreopen：\n```\nfreopen(\"题目名.in\",\"r\",stdin);\nfreopen(\"题目名.out\",\"w\",stdout);\n```\n\n`\"r\"` 一定要用双引号！\n\n文件夹：\n\n```\n|----- 考号\n  ｜----- T1名字\n    ｜----- T1名字.cpp\n  ｜----- T2名字\n    ｜----- T2名字.cpp\n  ｜----- T3名字\n    ｜----- T3名字.cpp\n  ｜----- T4名字\n    ｜----- T4名字.cpp\n```\n\n另外你需要注意文件的后缀名：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c9na8ao1.png)\n\n这里引用一些 @chenxi2009 的图，我是用 mac 的，拍不了。\n\n不然就可能出现 `duel.cpp.cpp` 的情况。\n\n还有文件名一定要检查是否跟题目一模一样！\n\n## #define int long long\n\n是可以的~~因为我用过~~。\n\nCCF 下发的 pdf 文件中提到：主函数返回类型只能是 int。\n\n所以 signed main 行吗？\n\n但是 `signed=int=signed int`，可以的~~因为我用过~~。\n\n虽然可以用，但是有可能空间爆炸。\n\n## 读入\n\n习惯用 `cin/cout` 的可以用 ```ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);```\n\n爱用 `scanf/printf` 也可以，但是要注意类型是否正确。\n"
  },
  {
    "title": "t1761898741aoO___0C5pp1WUqC.md",
    "content": "# 题解：P10161 [DTCPC 2024] 小方的疑惑 10\nposted on 2025-10-31 08:19:01 | under  | [source](https://www.luogu.com.cn/blog/_post/1074313)\n\n## 思路\n\n我们注意到答案串一定是若干个可以变成一个可以做出 $k$ 个合法的括号序列的长度 $\\le n$ 的序列再补上若干个 `)`。\n\n显然，设答案串 $s$ 有 $k$ 对括号在最外层，那么合法子串个数为 $\\frac{k(k+1)}{2}$。我们就可以构造了！\n\n这样就可以在不浪费括号的情况下将答案串分成多个括号串。\n\n设 $dp_i$ 为构造出 $i$ 个合法子串（即 $k$）所需的最小括号对数。\n\n状态转移就是：$dp_i=dp_{i-\\frac{j(j+1)}{2}}+j$。\n\n我们先把这部分预处理出来。\n\n如果 $2dp_k>n$ 则说明无解，否则在 dp 数组上递归构造（如果$dp_i=dp_{i-\\frac{j(j+1)}{2}}+j$，那么就转移）。\n\n## 代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint T,n,k,dp[100005];\nvoid print(int x){\n    if(!x) return;\n    for(int i=1;i*(i+1)/2<=x;i++)if(dp[x-i*(i+1)/2]+i==dp[x])\n        {for(int j=1;j<i;j++) cout<<\"()\";cout<<\"(\",print(x-i*(i+1)/2),cout<<\")\";return;}\n}signed main(){\n    cin>>T,memset(dp,0x3f,sizeof dp),dp[0]=0;\n    for(int i=1;i<=100000;i++)\n        for(int j=1;j*(j+1)/2<=i;j++) dp[i]=min(dp[i],dp[i-j*(j+1)/2]+j);\n    while(T--){\n        cin>>n>>k;if(dp[k]*2>n){cout<<\"-1\\n\"; continue;}\n        print(k);for(int i=dp[k]*2+1;i<=n;i++)cout<<\")\";cout<<'\\n';\n    }\n}\n```\n"
  },
  {
    "title": "t1761363199pPJ3fkIjB01_YCqj.md",
    "content": "# 题解：P12131 [蓝桥杯 2025 省 B] 客流量上限\nposted on 2025-10-25 03:33:19 | under  | [source](https://www.luogu.com.cn/blog/_post/1069509)\n\n## 思路\n因为对于任意分店 $i$ 和 $j(1\\le i,j\\le2025)$，它们的客流量上限 $A_i$ 和 $A_j$ 的乘积不得超过 $ij+2025$。\n\n所以，对于任意分店 $i$，$A_i\\le\\sqrt{i^2+2025}$。\n\n我们直接打表：\n\n```cpp\nfor(int i=1;i<=2025;i++) cout<<(int)sqrt(i*i+2025)<<' ';\n```\n\n发现在 $i\\ge1013$ 时 $A_i \\le i$。\n\n那么当 $1\\le i<1013\\le j\\le2025$ 时，$A_iA_j=A_ij,A_iA_j\\le ij+2025$。\n\n两边同除 $j$：$A_i\\le i+\\frac{2025}{j}$。\n\n发现：$A_i\\le i+\\lfloor\\frac{2025}{j}\\rfloor$。\n\n由于 $1013\\le j\\le2025$，所以，$A_i\\in[1,i+1]$。\n\n所以我们可以得出：\n\n$A_1$ 有 $2$ 种选择；\n\n$A_k$ 为了不与 $A_1$~$A_{k-1}$ 选的重复，总是有 $i+1-(i-1)=2$ 种选择。\n\n所以答案就是 $2^{1012}$。\n\n然后就是算了，快速幂和枚举都行。\n"
  },
  {
    "title": "t1760752711WyQ-dWuJ5eYyA6Ll.md",
    "content": "# 题解：P10578 [蓝桥杯 2024 国 A] 旋转九宫格\nposted on 2025-10-18 01:58:31 | under  | [source](https://www.luogu.com.cn/blog/_post/1064369)\n\n用 BFS。\n\n## 思路\n\n- 我们可以使用一个长度为 $3\\times3$ 的 `string` 来表示状态，每一种状态可以进行旋转（左上，右上，左下，右下）。\n- 我们可以用 map 来记录状态。\n- 预处理一下即可。\n## 代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nmap<string,int> mp; int T,n; char c;\nsigned main(){\n\tcin>>T; queue<string> q; //bfs\n\tq.push(\"123456789\"),mp[\"123456789\"]=1;\n\twhile(q.size()){\n\t\tstring u=q.front(),v[4]={u,u,u,u}; q.pop();\n\t\tv[3][4]=u[5],v[3][5]=u[8],v[3][7]=u[4],v[3][8]=u[7];\n\t\tv[2][3]=u[4],v[2][4]=u[7],v[2][6]=u[3],v[2][7]=u[6];\n\t\tv[1][1]=u[2],v[1][2]=u[5],v[1][4]=u[1],v[1][5]=u[4];\n\t\tv[0][0]=u[1],v[0][1]=u[4],v[0][3]=u[0],v[0][4]=u[3];\n\t\tfor(int i=0;i<4;i++) if(!mp[v[i]]){\n\t\t\tmp[v[i]]=mp[u]+1;if(v[i]==\"0123456789\")break;q.push(v[i]);\n\t\t}\n\t}while(T--){\n\t\tstring s;\n\t\tfor(int i=0;i<9;i++) cin>>c,s+=c;\n\t\tcout<<mp[s]-1<<'\\n';\n\t}return 0;\n}\n```\n"
  },
  {
    "title": "t1760693795dMCtqay9ikpBsmPO.md",
    "content": "# 数位 DP 学习笔记\nposted on 2025-10-17 09:36:35 | under  | [source](https://www.luogu.com.cn/blog/_post/1063960)\n\n## 原理\n\n### 前言\n\n数位 DP 一般解决在 $[a,b]$ 中满足一个关于**数的组成**的条件的个数。\n\n---\n我们发现在位数较多时，例如：$10000\\dots19999,50000\\dots59999$。\n\n我们发现它们都是后 $4$ 位从 $0000$ 变到 $9999$，十分相似。\n\n然后，我们发现只有万位是变的，就可以统计个数了！\n\n### 例题：\n\n我们直接看例题。\n\n#### 例一 [P1239 计数器](https://www.luogu.com.cn/problem/P1239)\n\n$f_i$ 代表在有 $i$ 位数字的情况下，每个数字有多少个。\n\n## 总结\n\n数位 DP 一般具有这几个特征：\n\n1. 要求统计满足一定条件的数的数量。\n\n2. 一般跟数位（数的组成）有关（不然呢）\n\n3. 上界很大（比如 $10^{18}$），暴力枚举验证会超时。\n"
  },
  {
    "title": "t1759652007UM8dTGAozo0wtMom.md",
    "content": "# 题解：P10414 [蓝桥杯 2023 国 A] 2023 次方\nposted on 2025-10-05 08:13:27 | under  | [source](https://www.luogu.com.cn/blog/_post/1055944)\n\n## 前言\n\n这个应该小学生都可以看懂吧（本题解没有用到任何较难的知识）。\n\n~~好像我也是小学生唉~~。\n\n#### 前置小知识\n\n$a\\bmod b=c$ 代表取模，即 $a$ 除 $b$ 的余数是 $c$。\n\n## 题意\n\n求 $ 2^{(3^{(4^{(\\ldots ^{2023})})})} \\bmod2023$。\n\n## 思路\n\n因为这个式子过于复杂，所以要简化一下。\n\n根据小学的知识，**找规律！！！**\n\n但是手算是不行的，写个程序：\n\n```cpp\nint s=3,sum=0,vis[2025]={};\nwhile(!vis[s]){\n    vis[s]=1;\n    s=(s*3)%2023;\n    sum++;\n}cout<<sum;\n```\n\n得出每 $408$ 个数为一个周期。\n\n之后我们还需要知道指数在周期外的个数（即$ 3^{(4^{(\\ldots ^{2023})})}\\bmod 408$）。\n\n一样，还是**找规律**：\n\n```cpp\nint s=3,sum=0,vis[2025]={};\nwhile(!vis[s]){\n    vis[s]=1;\n    s=(s*3)%2023;\n    sum++;\n}cout<<sum;\n```\n\n得出每 $16$ 个数为一个周期。\n\n我们又发现 $4\\times4=16$，得出 $4^{(5^{(6^{(\\ldots ^{2023})})})} \\bmod16=0$。\n\n所以可以得出 $ 3^{(4^{(5^{(\\ldots ^{2023})})})} \\bmod408=273$。\n\n推一下，还可以得出 $ 2^{(3^{(4^{(\\ldots ^{2023})})})} \\bmod2023=2^{273}$。\n\n然后又用程序跑一遍，得出 $2^{273} \\bmod =869$。\n\n所以答案是 $869$。\n"
  },
  {
    "title": "t1759643913zh4zJHCpJrrod8w9.md",
    "content": "# 题解：P10492 Weather Forecast\nposted on 2025-10-05 05:58:33 | under  | [source](https://www.luogu.com.cn/blog/_post/1055770)\n\n记忆化搜索+剪枝。\n\n记忆化，记录：\n\n- 目前到的点 $(x,y)$。\n- 天数 $day$。\n- 四个角的降雨量。\n\n剪枝：\n\n1. 如果活动时下雨，直接剪掉。\n2. 如果四个角没有下雨 $\\ge 7$ 天，直接剪掉。因为四个角地方被覆盖的情况是最少的。\n\n代码:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[405][5][5],f[5][5][405][8][8][8][8];\nint dx[]={-1,0,-2,0,2,0,1,0,0},dy[]={0,-1,0,-2,0,2,0,1,0};\nint dfs(int x,int y,int day,int ex,int sx,int ey,int sy){\n\tif(f[x][y][day][ex][sx][ey][sy]!=-1)\n\t\treturn f[x][y][day][ex][sx][ey][sy];\n\tfor(int i=x;i<=x+1;i++) for(int j=y;j<=y+1;j++)\n\t\t\tif(a[day][i][j]==1) return 0;\n\tif(ex>=7||sx>=7||ey>=7||sy>=7) return 0;\n\tif(day==n) return 1;\n\tint ans=0;\n\tfor(int i=0;i<9;i++){\n\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\tif(1<=tx&&tx<=3&&1<=ty&&ty<=3){\n\t\t\tint a,b,c,d;\n\t\t\tif(tx==1&&ty==1)a=0;else a=ex+1;\n\t\t\tif(tx==3&&ty==1)b=0;else b=sx+1;\n\t\t\tif(tx==1&&ty==3)c=0;else c=ey+1;\n\t\t\tif(tx==3&&ty==3)d=0;else d=sy+1;\n\t\t\tans|=dfs(tx,ty,day+1,a,b,c,d);\n\t\t}\n\t}if(f[x][y][day][ex][sx][ey][sy]==-1)\n\t\tf[x][y][day][ex][sx][ey][sy]=ans;\n\treturn ans;\n}int main(){\n\twhile(1){\n\t\tmemset(f,-1,sizeof(f)),cin>>n;\n\t\tif(n==0) break;\n\t\tfor(int i=1;i<=n;i++) for(int j=1;j<=4;j++)\n\t\t\tfor(int k=1;k<=4;k++) cin>>a[i][j][k];\n\t\tcout<<dfs(2,2,1,1,1,1,1)<<'\\n';\n\t}\n}\n```\n"
  },
  {
    "title": "t1758703528I-wUPLMAa5lweGyU.md",
    "content": "# 1\nposted on 2025-09-24 08:45:28 | under  | [source](https://www.luogu.com.cn/blog/_post/1048317)\n\n问你 $1,3,5,\\dots,2n+1$ 凑成 24 的方案（可用 $+,-,\\times$）\n\n$n\\le7$:\n\n```\n7+5=12 3-1=2 2*12=24 ::1~7\n3*9=27 7-5=2 27-2=25 25-1=24 ::1~9\n1*5=5 3*7=21 11-9=2 5+21=26 26-2=24 ::1~11\n1*13=13 3+9=12 5+7=12 12-12=0 13+0=13 13+11=24  ::1~13\n```\n\n$n>7$:\n"
  },
  {
    "title": "t1757077897p92mEfUx8qzncNnj.md",
    "content": "# 题解：CF1766C Hamiltonian Wall\nposted on 2025-09-05 13:11:37 | under  | [source](https://www.luogu.com.cn/blog/_post/1038028)\n\n题目就是求 $s$ 是否可以一笔画。\n\n像这样（样例）：\n\n```\nBWBBWB\nBBBBBB\n```\n\n走法：\n\n```\nB  W  B--B  W  B\n|     |  |     |\nB--B--B  B--B--B\n```\n\n我们发现如果上面或下面没有走过且可以走，是一定要走。\n\n如果上面或下面都走过了，就向后走。\n\n另外形如：\n\n```\nBB\nBW\n```\n\n就要特判是开始是第一行还是第二行，我的做法是都枚举一遍。\n\n最后放上超长代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint T,n,fg,as,x,y,vis[200005][2]; char s[200005][2];\nsigned main(){\n    cin>>T;\n    while(T--){\n        cin>>n,fg=as=0;\n        for(int i=1;i<=n;i++) cin>>s[i][0];\n        for(int i=1;i<=n;i++) cin>>s[i][1];\n        for(int i=1;i<=n;i++)\n            if(s[i][0]=='B'||s[i][1]=='B'){\n                fg=i; break;\n            }x=fg,y=0;\n        if(s[x][0]==s[x][1]){\n            y=0; int ans=0;\n            while(x<n){\n                if(s[x][1-y]=='B') y=1-y;\n                // cout<<x<<' '<<y<<' '<<s[x+1][y]<<'\\n';\n                if(s[x+1][y]=='B') x++;\n                else{as=1; break;}\n            }if(!as) ans=1;\n            x=fg,y=1,as=0;\n            while(x<n){\n                if(s[x][1-y]=='B') y=1-y;\n                // cout<<x<<' '<<y<<' '<<s[x+1][y]<<'\\n';\n                if(s[x+1][y]=='B') x++;\n                else{as=1; break;}\n            }if(!as) ans=1;\n            if(ans) cout<<\"YES\\n\";\n            else cout<<\"NO\\n\";\n        }else{\n            if(s[x][0]=='B') y=0;\n            else y=1;\n            while(x<n){\n                if(s[x][1-y]=='B') y=1-y;\n                // cout<<x<<' '<<y<<' '<<s[x+1][y]<<'\\n';\n                if(s[x+1][y]=='B') x++;\n                else{as=1; break;}\n            }if(as) cout<<\"NO\\n\";\n            else cout<<\"YES\\n\";\n        }\n    }\n}\n```\n"
  },
  {
    "title": "t1757072778zyX7_7OjGqZpOLeb.md",
    "content": "# 题解：CF2086C Disappearing Permutation\nposted on 2025-09-05 11:46:18 | under  | [source](https://www.luogu.com.cn/blog/_post/1037961)\n\n## 题意\n\n给定两个排列 $p$ 和 $d$，第 $1 \\le i \\le n$ 次将 $p_{d_i}$  设为 0。\n\n然后进行操作，一次操作定义为指定一个 $i$，将 $a_i = i$，问最少多少次操作能将它复原为一个排列（可能与原排列相同）。\n\n## 思路\n\n我一看，每次 $p_{i}$ 一定要做一次操作 $p_i=i$，那么 $p_{p_i}$ 也要操作，以此类推，直到 $p_k$ 等于 $k$。\n\n那就好办了，每次讲 $p_i$ 和 $i$ 连在一起，分成几个联通块，每次的答案就是联通块的大小。\n\n## code\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint T,n,p[100005],d[100005],f[100005],sz[100005],fg[100005],ans;\nint fd(int x){\n    if(f[x]==x) return x;\n    return f[x]=fd(f[x]);\n}\nsigned main(){\n    cin>>T;\n    while(T--){\n        cin>>n,ans=0;\n        for(int i=1;i<=n;i++) f[i]=i,sz[i]=1,fg[i]=0;\n        for(int i=1;i<=n;i++){\n            cin>>p[i];\n            if(fd(p[i])!=fd(i))\n                sz[fd(i)]+=sz[fd(p[i])],f[fd(p[i])]=fd(i);\n        }for(int i=1;i<=n;i++){\n            cin>>d[i];\n            if(!fg[fd(d[i])]) fg[fd(d[i])]=1,ans+=sz[fd(d[i])];\n            cout<<ans<<' ';\n        }cout<<'\\n';\n    }\n}\n```\n"
  },
  {
    "title": "t1755508497uOe3G8IXGt_dWApf.md",
    "content": "# 题解：P7900 [COCI 2006/2007 #2] SJECIŠTA\nposted on 2025-08-18 09:14:57 | under  | [source](https://www.luogu.com.cn/blog/_post/1025788)\n\n## 题意：\n\n给定一个没有任何三个及以上的对角线交于一点的凸多边形。\n\n问对角线交点个数。\n\n## 思路：\n\n我们注意到任意两个对角线一定可以确定一个点。\n\n那么只要求出对角线数量就行了！\n\n## 解法：\n\n确定两个对角线就是找到四个点。\n\n即在 $n$ 个点中**选** $4$ 个点。\n\n所以答案就是 $C^4_n$。\n"
  },
  {
    "title": "t1742718043mMvzoPIBGYA71YRf.md",
    "content": "# 模板\nposted on 2025-03-23 08:20:43 | under  | [source](https://www.luogu.com.cn/blog/_post/940299)\n\n模板\n\n## KMP\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nstring s,p;\nint n,m,pmt[1000005];\nsigned main(){\n    cin>>s>>p,n=s.size(),m=p.size();\n    for(int i=1,j=0;i<m;i++){\n        while(j&&p[i]!=p[j]) j=pmt[j-1];\n        if(p[i]==p[j]) j++;\n        pmt[i]=j;\n    }for(int i=0,j=0;i<n;i++){\n        while(j&&s[i]!=p[j]) j=pmt[j-1];\n        if(s[i]==p[j]) j++;\n        if(j==m) cout<<i-j+2<<'\\n',j=pmt[j-1];\n    }for(int i=0;i<m;i++) cout<<pmt[i]<<' ';\n}\n```\n\n## 负环（spfa)\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint n,m,en=0,eh[10005],dis[10005],cnt[10005],vis[10005],inf=0x3f3f3f3f,t;\nqueue<int> q;\nstruct edge{\n\tint to,nxt,w;\n}e[1000005];\nvoid add(int u,int v,int w){ \n\te[en].to = v;\n\te[en].nxt = eh[u];\n\te[en].w = w;\n\teh[u] = en++;\n}\nvoid init(){\n\tmemset(eh,-1,sizeof(eh));\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(cnt,0,sizeof(cnt));\n\tmemset(vis,0,sizeof(vis));\n\ten = 0; \n\twhile(!q.empty()) q.pop();\n}\nvoid spfa(){\n\tdis[1]=0,vis[1]=1,q.push(1);\n\tint u,v,w;\n\twhile(!q.empty()){\n\t\tu=q.front(); q.pop();\n\t\t//cout << u << endl;\n\t\tfor(int i=eh[u];~i;i=e[i].nxt){\n\t\t\tv=e[i].to;w=e[i].w;\n\t\t\t//cout << u << \" \" << v << \" \" << cnt[v] <<endl;\n\t\t\tif(dis[u]+w<dis[v]){\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tcnt[v] = cnt[u] + 1;\n\t\t\t\t//cout << u << \" \" << v << \" \" << cnt[v] <<endl;\n\t\t\t\tif(cnt[v]>=n){cout<<\"YES\\n\"; return;}\n\t\t\t\tif(!vis[v]){\n\t\t\t\t\tvis[v]=1,q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvis[u]=0; \n\t}\n\tcout<<\"NO\\n\";\n}\nint main() {\n\tcin>>t;\n    while(t--){\n        cin>>n>>m;\n        init();\n        while(m--){\n            int u,v,w;\n            cin>>u>>v>>w;\n            add(u,v,w);\n            if(w>=0) add(v,u,w);\n        }\n        spfa();\n    }\n}\n```\n\n## 快速幂\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint pw(int a,int b,int p){\n    int ans=1,bs=a;\n    while(b){\n        if(b&1) ans=ans*bs%p;\n        bs=bs*bs%p;\n        b>>=1;\n    }\n    return ans;\n}\nint a,b,p;\nsigned main(){\n\tcin>>a>>b>>p;\n\tprintf(\"%d^%d mod %d=%d\",a,b,p,pw(a,b,p));\n\treturn 0;\n}\n```\n\n## 字典树\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint T,q,n,t[3000005][65],cnt[3000005],idx; char s[3000005];\nint getnum(char x){\n    if(x>='A'&&x<='Z')\n        return x-'A';\n    else if(x>='a'&&x<='z')\n        return x-'a'+26;\n    else\n        return x-'0'+52;\n} \nvoid insert(char str[]){\n    int p=0,len=strlen(str);\n    for(int i=0;i<len;i++){\n        int c=getnum(str[i]);\n        if(!t[p][c]) t[p][c]=++idx;\n        p=t[p][c],cnt[p]++;\n    }\n}\nint find(char str[]){\n    int p=0,len=strlen(str);\n    for(int i=0;i<len;i++){\n        int c=getnum(str[i]);\n        if(!t[p][c]) return 0;\n        p=t[p][c];\n    }\n    return cnt[p];\n}\nsigned main(){\n    scanf(\"%d\",&T);\n    while(T--){\n        for(int i=0;i<=idx;i++) for(int j=0;j<=122;j++) t[i][j]=0;\n        for(int i=0;i<=idx;i++) cnt[i]=0;\n        idx=0,scanf(\"%d%d\",&n,&q);\n        for(int i=1;i<=n;i++) scanf(\"%s\",s),insert(s);\n        for(int i=1;i<=q;i++) scanf(\"%s\",s),printf(\"%d\\n\",find(s));\n    }\n    return 0;\n}\n```\n\n## 并查集\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,z,x,y,a[10005];\nint f(int x){\n\tif(a[x]!=x) a[x]=f(a[x]);\n\treturn a[x];\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) a[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>z>>x>>y;\n\t\tif(z==1) a[f(x)]=f(y);\n\t\telse if(f(x)==f(y)) cout<<\"Y\\n\";\n\t\telse cout<<\"N\\n\";\n\t}\n\treturn 0;\n}\n```\n\n## 笛卡尔树\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,a[10000005],st[10000005],ls[10000005],rs[10000005],l,r;\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin>>n;\n    int pos=0,top=0;\n    for(int i=1;i<=n;i++){\n        cin>>a[i],pos=top;\n        while(pos&&a[st[pos]]>a[i]) pos--;\n        if(pos) rs[st[pos]]=i;\n        if(pos<top) ls[i]=st[pos+1];\n        st[top=++pos]=i;\n    }\n    for(int i=1;i<=n;i++) l^=i*(ls[i]+1ll),r^=i*(rs[i]+1ll);\n    cout<<l<<' '<<r;\n}\n```\n\n## 欧拉路径\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,u,v,del[100005],du[100005][2]; \nstack<int> st; vector<int> g[100005];\nvoid dfs(int now){\n\tfor(int i=del[now];i<g[now].size();i=del[now]) del[now]=i+1,dfs(g[now][i]);\n\tst.push(now);\n}\nsigned main(){\n\tcin>>n>>m;\n    for(int i=1;i<=m;i++) cin>>u>>v,g[u].push_back(v),du[u][1]++,du[v][0]++;  \n    for(int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());\n    int s=1,cnt[2]={0,0},flag=1;\n    for(int i=1;i<=n;i++){\n        if(du[i][1]!=du[i][0]){\n            flag=0;\n            if(du[i][1]-du[i][0]==1) cnt[1]++,s=i;\n            else if(du[i][0]-du[i][1]==1) cnt[0]++;\n            else{\n            \tcout<<\"No\\n\";\n            \treturn 0;\n\t\t\t}\n        }\n    }\n    if((!flag)&&!(cnt[0]==cnt[1]&&cnt[0]==1)){\n    \tcout<<\"No\\n\";\n        return 0;\n\t}\n    dfs(s);\n    while(st.size()) cout<<st.top()<<' ',st.pop();\n    return 0; \n}\n```\n\n## 线段树\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nint a[1000005],n,m,q,x,y,z;\nstruct tree{ int l,r,p,ad; }t[4000005];\nvoid b(int p,int l,int r){\n    t[p].l=l,t[p].r=r;\n    if(l==r){ t[p].p=a[l]; return; }\n    int mid=l+r>>1;\n    b(p*2,l,mid),b(p*2+1,mid+1,r),t[p].p=t[p*2].p+t[p*2+1].p;\n}\nvoid s(int p){\n    if(t[p].ad){\n        t[p*2].p+=t[p].ad*(t[p*2].r-t[p*2].l+1);\n        t[p*2+1].p+=t[p].ad*(t[p*2+1].r-t[p*2+1].l+1);\n        t[p*2].ad+=t[p].ad,t[p*2+1].ad+=t[p].ad,t[p].ad=0;\n    }\n}\nvoid c(int p,int x,int y,int z){\n    if(x<=t[p].l&&y>=t[p].r){ t[p].p+=z*(t[p].r-t[p].l+1),t[p].ad+=z; return; }s(p);\n    int mid=t[p].l+t[p].r>>1;\n    if(x<=mid) c(p*2,x,y,z);\n    if(y>mid) c(p*2+1,x,y,z);\n    t[p].p=t[p*2].p+t[p*2+1].p;\n}\nint ask(int p,int x,int y){\n    if(x<=t[p].l&&y>=t[p].r) return t[p].p;\n    s(p);int mid=t[p].l+t[p].r>>1,ans=0;\n    if(x<=mid) ans+=ask(p*2,x,y);\n    if(y>mid) ans+=ask(p*2+1,x,y);\n    return ans;\n}\nsigned main(){\n\tcin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    b(1,1,n);\n    for(int i=1;i<=m;i++){\n        cin>>q;\n        if(q==1) cin>>x>>y>>z,c(1,x,y,z);\n        else cin>>x>>y,cout<<ask(1,x,y)<<'\\n';\n    }\n    return 0;\n}\n```\n\n## 树状数组\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,a,f,x,y,t[2000005];\nint lb(int k){ return k&-k; }\nvoid add(int x,int k){\n    while(x<=n) t[x]+=k,x+=lb(x);\n}int sum(int x){\n    int ans=0;\n    while(x) ans+=t[x],x-=lb(x);\n    return ans;\n}signed main(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>a,add(i,a);\n    for(int i=1;i<=m;i++){\n        cin>>f>>x>>y;\n        if(f==1) add(x,y);\n        else cout<<sum(y)-sum(x-1)<<'\\n';\n    }\n}\n```\n\n## 线性筛\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nbool a[100000005];\nint ans[10000005],cnt,n,q,tmp;\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n    cin>>n>>q;\n    a[0]=a[1]=1;\n    for(int i=2;i*i<=n;i++) if(!a[i]) for(int j=i*i;j<=n;j+=i) a[j]=1;\n    for(int i=2;i<=n;i++) if(!a[i]) ans[++cnt]=i;\n    for(int i=1;i<=q;i++){\n    \tcin>>tmp;\n    \tcout<<ans[tmp]<<'\\n';\n\t}\n\treturn 0;\n}\n```\n\n## hash\n\n```cpp\n#include<bits/stdc++.h>\n#define int unsigned long long\nusing namespace std;\nstring x; int n,t,a[1000005];\nint h(string x){\n    int b=129,l=x.size(),s=0;\n    for(int i=0;i<l;i++) s=s*b+x[i];\n    return s;\n}\nsigned main(){\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>x,a[i]=h(x);\n    sort(a+1,a+n+1);\n    for(int i=2;i<=n;i++) if(a[i]!=a[i-1]) t++;\n    cout<<t+1;\n    return 0;\n}\n```\n\n## 最小生成树\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,tot,k,f[100005],m,ex;\nstruct stu{int u,v,w;}a[500005];\nbool cmp(stu a,stu b){return a.w<b.w;}\nint fd(int x){\n    if(x==f[x]) return x;\n    return f[x]=fd(f[x]);\n}\nvoid kruskal(){\n    for(int i=1;i<=n;i++) f[i]=i;\n    sort(a+1,a+m+1,cmp);\n    for(int i=1;i<=m;i++){\n        if(k==n-1) break;\n        if(fd(a[i].u)!=fd(a[i].v)) f[fd(a[i].u)]=fd(a[i].v),tot+=a[i].w,k++;\n    }\n    if(k==n-1)cout<<tot;\n    else cout<<\"orz\";\n}\nsigned main(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) cin>>a[i].u>>a[i].v>>a[i].w;\n    kruskal();\n}\n```\n\n## RMQ\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,f[1000005][45],x,y;\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>f[i][0];\n\tfor(int j=1;j<=20;j++) for(int i=1;i<=n;i++) f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>x>>y; int l=log2(y-x+1);\n\t\tcout<<max(f[x][l],f[y-(1<<l)+1][l])<<'\\n';\n\t}\n\treturn 0;\n}\n```\n\n## 拓扑排序\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,o,in[105];\nqueue<int> q;\nvector<int> v[105];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(cin>>o){\n\t\t\tif(o==0) break;\n\t\t\tin[o]++;\n\t\t\tv[i].push_back(o); \n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) if(in[i]==0) q.push(i);\n\twhile(q.size()){\n\t\tint tmp=q.front();\n\t\tcout<<tmp<<' ';\n\t\tq.pop();\n\t\tfor(int i=0;i<v[tmp].size();i++){\n\t\t\tin[v[tmp][i]]--;\n\t\t\tif(in[v[tmp][i]]==0) q.push(v[tmp][i]); \n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## LCA(tarjan)\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,s,u,v,f[500005],vis[500005],lca[5000005];\nvector<pair<int,int> > q[500005];\nvector<int> mp[500005];\nint find(int x){\n\tif(f[x]!=x) f[x]=find(f[x]);\n\treturn f[x];\n}\nvoid tarjan(int now){\n\tvis[now]=1;\n\tfor(int i=0;i<mp[now].size();i++){\n\t\tint p=mp[now][i];\n\t\tif(vis[p]==0) tarjan(p),f[p]=now;\n\t}\n\tfor(int i=0;i<q[now].size();i++){\n\t\tint x=q[now][i].first,id=q[now][i].second;\n\t\tif(vis[x]==2&&lca[id]==0) lca[id]=find(x);\n\t}vis[now]=2;\n}\nsigned main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>u>>v;\n\t\tmp[v].push_back(u);\n\t\tmp[u].push_back(v);\n\t}for(int i=1;i<=n;i++) f[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>u>>v;\n\t\tif(u==v) lca[i]=u;\n\t\telse q[v].push_back({u,i}),q[u].push_back({v,i});\n\t}tarjan(s);\n\tfor(int i=1;i<=m;i++) cout<<lca[i]<<'\\n';\n\treturn 0;\n}\n```\n\n## LCA(dfs)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,r,d,ds[500005],ml[25][500005],x,y;\nvector<int> e[500005];\nvoid dfs(int x,int f,int sum){\n\tml[0][x]=f,ds[x]=sum;\n\tfor(int i=0;i<e[x].size();i++) if(e[x][i]!=f) dfs(e[x][i],x,sum+1);\n}int lca(int x,int y){\n\tif(ds[x]<ds[y]) swap(x,y);\n\tfor(int i=20;~i;i--) if(ds[ml[i][x]]>=ds[y]) x=ml[i][x];\n\tif(x==y) return x;\n\tfor(int i=20;~i;i--) if(ml[i][x]!=ml[i][y]) x=ml[i][x],y=ml[i][y];\n\treturn ml[0][x];\n}int main(){\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m>>r;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>x>>y;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}dfs(r,0,1);\n\tfor(int i=1;i<=20;i++) for(int j=1;j<=n;j++) ml[i][j]=ml[i-1][ml[i-1][j]];\n\twhile(m--){\n\t\tcin>>x>>y;\n\t\tcout<<lca(x,y)<<'\\n';\n\t}\n\treturn 0;\n}\n```\n\n## 单调队列\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,a[1000005];\ndeque<int> q;\nsigned main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\twhile(q.size()&&a[q.back()]>a[i]) q.pop_back();\n\t\tq.push_back(i);\n\t\tif(i>=m){\n\t\t\twhile(q.size()&&q.front()<=i-m) q.pop_front();\n\t\t\tcout<<a[q.front()]<<' ';\n\t\t}\n\t}cout<<'\\n';\n\twhile(q.size()) q.pop_front();\n\tfor(int i=1;i<=n;i++){\n\t\twhile(q.size()&&a[q.back()]<a[i]) q.pop_back();\n\t\tq.push_back(i);\n\t\tif(i>=m){\n\t\t\twhile(q.size()&&q.front()<=i-m) q.pop_front();\n\t\t\tcout<<a[q.front()]<<' ';\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 最短路\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nstruct stu{\n    int v,w;\n    bool operator<(stu b)const{\n        return w>b.w;\n    }\n}now,tmp,et,t1,t2;\nint n,m,dis[500005],vis[500005],inf=0x3f3f3f3f,s;\nvector<stu> a[500005];\nvoid dijkstra(int s){\n    memset(dis,inf,sizeof(dis));\n    dis[s]=0;\n    now={s,0};\n    priority_queue<stu> q;\n    q.push(now);\n    while(q.size()){\n        now=q.top();\n        q.pop();\n        if(vis[now.v]) continue;\n        vis[now.v]=1;\n        for(int i=0;i<a[now.v].size();i++){\n            tmp=a[now.v][i];\n            if(dis[now.v]+tmp.w<dis[tmp.v]){\n                dis[tmp.v]=dis[now.v]+tmp.w;\n                et={tmp.v,dis[tmp.v]};\n                q.push(et); \n            }\n        }\n    }\n}\nsigned main() {\n    cin>>n>>m>>s;\n    while(m--){\n        int u,v,w;\n        cin>>u>>v>>w;\n        a[u].push_back({v,w}); \n    }dijkstra(s);\n    for(int i=1;i<=n;i++) cout<<dis[i]<<' ';\n}\n```\n\n# $\\Huge求赞！！！$\n\n# $\\Huge600行了$\n"
  },
  {
    "title": "t1742299246fo6EgcmnsYAV8IKi.md",
    "content": "# 题解：P3535 [POI 2012] TOU-Tour de Byteotia\nposted on 2025-03-18 12:00:46 | under  | [source](https://www.luogu.com.cn/blog/_post/937822)\n\n并查集板子。\n\n## 思路\n\n一条边如果没有我们所关注的点，可以直接不管，因为这些边不会影响我们需要的点。直接丢到并查集里维护即可。\n\n剩下的边贪心，能加的都要加。\n\n## 代码解释\n\n首先，$u_i>k$ 且 $v_i>k$ 的边一定要选，用并查集维护即可。\n\n```\nfor(int i=1;i<=m;i++){\n    cin>>u[i]>>v[i];\n    if(u[i]>v[i]) swap(u[i],v[i]);\n    if(u[i]>k&&v[i]>k) f[fd(u[i])]=fd(v[i]);\n}\n```\n\n然后，剩下 $u_i \\le k$ 或 $v_i \\le k$ 的边看情况选：\n\n1. 如果他们不在一个集合里（不会出现简单环），选并合并。\n2. 如果他们在一个集合里，不选并计入答案。\n\n```cpp\nfor(int i=1;i<=m;i++){\n    if(u[i]<=k||v[i]<=k){\n        if(fd(u[i])!=fd(v[i])) f[fd(u[i])]=fd(v[i]);\n        else ans[++tot][0]=u[i],ans[tot][1]=v[i];\n    }\n}\n```\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t1737525400HX-pYQPKlZFkPkLT.md",
    "content": "# 题解：P11601 『Fwb』狼人の杀戮\nposted on 2025-01-22 05:56:40 | under  | [source](https://www.luogu.com.cn/blog/_post/907630)\n\n比较烦的中模拟。\n\n## 注意事项：\n\n1. 猎人死时必须带走一个人。\n2. 女巫只有一份毒药和解药。\n3. 在同一晚，同一位女巫只能做一次操作。\n4. 如果错误**撤回当晚所有操作**。\n\n## 操作：\n\n我们维护十个数组：\n\n-  $die$，所有死亡的记录。\n- $nw1$，女巫的毒药操作。\n- $nw2$，女巫的解药操作。\n- $nd$，当晚死亡人数。\n- $nnw$，当晚女巫的操作。\n- $lr$，当晚狼人的操作。\n- $er$，猎人带走的操作。\n- $die1$，$die$ 的副本。\n- $nw1\\_1$，$nw1$ 的副本。\n- $nw2\\_1$，$nw2$ 的副本。\n\n然后，几个 $\\texttt {if}$ 判断一下：\n\n1. 判断是否出界。\n2. 判断是否死亡。\n3. 如果是猎人或女巫，要判断是否当晚死亡。\n4. 如果是狼人或女巫，要判断是否当晚用。\n\n接着，记录死亡，是否用技能：\n\n```cpp\nif(op==0){ //狼人\n    if(a[x]==1&&!die[x]&&!die[y]&&!lr[x]&&x<=n&&x&&y<=n&&y&&x!=y)\n        die[y]=1,nd[y]=1,lr[x]=1,er[y]=0;\n    else fg=1;}\nif(op==1){ //毒药\n    if(a[x]==4&&!die[x]&&!die[y]&&!nw1[x]&&!nnw[x]&&x<=n&&x&&y<=n&&y&&x!=y)\n        die[y]=1,nw1[x]=1,nnw[x]=1,nd[y]=1,er[y]=0;\n    else fg=1;} \nif(op==2){ //解药\n    if(a[x]==4&&!nw2[x]&&((!die[x]||x==y)&&die[y])&&!nnw[x]&&x<=n&&x&&y<=n&&y&&nd[y])\n        die[y]=0,nw2[x]=1,nd[y]=0,nnw[x]=1;\n    else fg=1;}\nif(op==3){ //猎人\n    if(a[x]==3&&!er[x]&&nd[x]&&!die[y]&&x<=n&&x&&y<=n&&y&&x!=y)\n        die[y]=1,nd[y]=1,er[x]=1;\n    else fg=1;}\n```\n\n最后输出 $nd$ 就行了。\n"
  },
  {
    "title": "t1735390590-MdW2FNEQpk36QBK.md",
    "content": "# 树状数组\nposted on 2024-12-28 12:56:30 | under  | [source](https://www.luogu.com.cn/blog/_post/891951)\n\n## [习题](https://www.luogu.com.cn/problem/P3374)\n\n### 首先：\n\n要说树状数组，就必须要说 $\\operatorname{lowbit}$。\n\n那 $\\operatorname{lowbit}$ 是什么呢？\n\n是一个数的二进制从右往左第一个 $1$ 的值。\n\n例如，$\\operatorname{lowbit}(14)$ 是 $2$，$\\operatorname{lowbit}(16)$ 是 $16$。\n\n那应该怎么求呢？\n\n是 $n\\&-n$，众所周知 $-n$ 是 $n$ 的补码，就是 $n$ 按位取反再加 $1$。\n\n神奇的是，$n$ 这样一取反前面的 $0$ 都成 $1$ 了，再加一，$1$ 又变成 $0$ 了，但取反后第一个 $0$ 就成 $1$ 了，竟跟取反前一模一样！\n\n这样一来，只要第一个 $1$ 剩下来了。\n\n我们在举个栗子：\n\n$6$ 的二进制是 $110$，补码是 $010$，$\\operatorname{lowbit}(6)$ 就是 $2$。\n\n$24$ 的二进制是 $11000$，补码是 $01000$，$\\operatorname{lowbit}(6)$ 就是 $8$。\n\n### 之后（进入正题）：\n\n我们有一个数列（随便写的）：\n\n$$a\\{8\\}=\\{1,1,4,3,7,9,2,5\\}$$\n\n再写一个表，每个数为下面的两数之和：\n\n`           32           `\n\n`      9     ` `      23    `\n\n`   2  ` `   7  ` `  16  ` `   7  `\n\n`1` `1` `4` `3` `7` `9` `2` `5`\n\n我们要实现的是：\n\n1. 单点修改。\n2. 询问区间。\n\n但我们可以做出优化：\n\n我们发现，如下的点会被用过\n\n`           32           `\n\n`      9     ` `          `\n\n`   2  ` `    ` `  16  ` `    `\n\n`1` ` ` `4` ` ` `7` ` ` `2` ` `\n\n标号：\n\n$~~~~~~~~~~~~~~~~~~~t_8$\n\n`           32           `\n\n$~~~~~~~~~t_4$\n\n`      9     ` `          `\n\n$~~~~t_2~~~~~~~~~~~~~~~~~t_6$\n\n`   2  ` `    ` `  16  ` `    `\n\n$~t_1~~~~~~~t_3~~~~~~~~t_5~~~~~~~~t_7$\n\n`1` ` ` `4` ` ` `7` ` ` `2` ` `\n\n显然：若 $i$ 为奇数，$t_i$ 等于 $a_i$。\n\n观察可得 $t_i=a_i+a_{i+1}+...+a_{\\operatorname{lowbit}(i)+i-1}$。\n\n所以每次跳过 $\\operatorname{lowbit}(i)$ 即可。\n\n建树：\n\n每次都把包含 $x$ 的区间（即每次跳过 $\\operatorname{lowbit}(x)$）加上 $k$。\n\n```cpp\nvoid add(int x,int k){\n    while(x<=n) t[x]+=k,x+=lb(x);\n}\n```\n\n查询：\n\n与上面同理。\n\n```cpp\nint sum(int x){\n    int ans=0;\n    while(x) ans+=t[x],x-=lb(x);\n    return ans;\n}\n```\n\n~~码字不易，求赞~~\n"
  },
  {
    "title": "t1734953419sXOEh-kprRgPX-Br.md",
    "content": "# 矩阵加速递推\nposted on 2024-12-23 11:30:19 | under  | [source](https://www.luogu.com.cn/blog/_post/888860)\n\nPS：本文章因篇幅有限，就不讲矩阵乘法和快速幂了。\n\n题目：\n\n$$F_n = \\left\\{\\begin{aligned} 1 \\space (n \\le 2) \\\\ F_{n-1}+F_{n-2} \\space (n\\ge 3) \\end{aligned}\\right.$$\n\n求 $F_n$。\n\n定义一个矩阵$[Base]$，使：\n\n$$\\begin{bmatrix}F_n,F_{n+1}\\end{bmatrix}\\times\\begin{bmatrix}Base\\end{bmatrix}=\\begin{bmatrix}F_{n+1},F_{n+2}\\end{bmatrix}$$\n\n那：\n\n$$\\begin{bmatrix}F_n,F_{n+1}\\end{bmatrix}\\times\\begin{bmatrix}Base\\end{bmatrix}^2=\\begin{bmatrix}F_{n+2},F_{n+3}\\end{bmatrix}$$\n\n$$\\begin{bmatrix}F_n,F_{n+1}\\end{bmatrix}\\times\\begin{bmatrix}Base\\end{bmatrix}^M=\\begin{bmatrix}F_{n+M},F_{n+M+1}\\end{bmatrix}$$\n\n所以：\n\n$$\\begin{bmatrix}F_1,F_{2}\\end{bmatrix}\\times\\begin{bmatrix}Base\\end{bmatrix}^{n-1}=\\begin{bmatrix}F_{n},F_{n+1}\\end{bmatrix}$$\n\n那我们只要找出 $\\begin{bmatrix}Base\\end{bmatrix}$ 就行了。\n\n经过构造：\n\n$$\\begin{bmatrix}Base\\end{bmatrix}=\\begin{bmatrix}1,1\\\\1,0\\end{bmatrix}$$\n\n$F_n$ 就是：\n\n$$\\begin{bmatrix}1,1\\end{bmatrix}\\times\\begin{bmatrix}1,1\\\\1,0\\end{bmatrix}^{n-1}$$\n\n我们只要得到了递推的公式，就可以找到 $[Base]$，从而加速递推。\n"
  },
  {
    "title": "t17346127146a_VuSq5qSVPcsf7.md",
    "content": "# 12.19~12.31写题报告\nposted on 2024-12-19 12:51:54 | under  | [source](https://www.luogu.com.cn/blog/_post/886427)\n\n[题目](https://www.luogu.com.cn/paste/dxzda6nw)\n\n## T 1\n\n最小生成树。\n\n### 刚开始的解法\n\n忽略 $tol_a+tol_b$，零分。\n\n### 之后\n\n设 $tol_x$ 为最小，向所有点建边。\n\n```cpp\nint axx=min_element(tol+1,tol+n+1)-tol,tot2=0;\nfor(int i=1;i<=n;i++) if(i!=axx){\n    if(mp[i*1000000+axx]) tot2+=min(tol[i]+tol[axx],mp[i*1000000+axx]);\n    else tot2+=tol[i]+tol[axx];\n}\n```\n\n### 最后\n\n要给整个图建如上的虚拟边：\n\n```cpp\nint axx=min_element(tol+1,tol+n+1)-tol;\nfor(int i=1;i<=n;i++) if(i!=axx)\n    a[++m]={i,axx,tol[i]+tol[axx]};\n```\n\n只要跑个 kruskal 就行了。\n\n## T 2\n\n暴力跑 dfs 回溯。\n\n选择出这 $n$ 架飞机的降落顺序。\n\n```cpp\nvoid dfs(int d){\n\tif(f) return;\n\tif(d>n){\n\t\tint ls=b[1].t+b[1].l,fg=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tif(ls>b[i].d+b[i].t) fg=0;\n\t\t\telse if(ls>b[i].t) ls+=b[i].l;\n\t\t\telse ls=b[i].l+b[i].t;\n\t\tif(fg) f=1;\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i]) vis[i]=1,b[d]=a[i],dfs(d+1),vis[i]=0;\n}\n```\n\n## T 3\n\n因为 $0<x\\le1$，当 $N$ 到一定值时 $\\sum_{i=1}^{N}\\frac{x^{i}}{i}\\le0.0001$。\n\n经过粗略估计，$N\\le10^5$。\n\n所以当 $N\\ge 10^5$ 时，就可以不算了。\n\n```cpp\nn=min(100000ll,n);\n```\n\n## T 4\n\n辗转相除。\n\n如果 $y=0$ ，$\\texttt{Ollie}$ 赢。\n\n如果 $x / y \\neq1$ ，$\\texttt{Stan}$ 赢。\n\n每一次跟辗转相除一样 $(y,x-y)$。\n\n```cpp\nbool ans(int x,int y){\n    if(!y) return 0;\n\tif(x/y!=1) return 1;\n\treturn !ans(y,x-y);\n}\n```\n\n## T 5\n\n并查集。\n\nFd 函数寻找环的长度，更新最小值。\n\n如果不是环，将 $f_i$ 更新为 $a_i$（加入环中）。\n\n```cpp\nint fd(int x){\n    cnt++;\n    if(x==f[x]) return x;\n    return fd(f[x]);\n}\n```\n\n\n\n```cpp\nif(fd(a[i])==i) ans=min(ans,cnt);\nelse f[i]=a[i];\n```\n\n## T 6\n\n深度为偶数判红，奇数判蓝，其他为灰色。\n\n用 dfs 遍历即可。\n\n\n```cpp\nvoid dfs(int x,int dep){\n\tvis[x]=1;\n\tfor(int y:v[x]){\n\t\tif(vis[y]) continue;\n\t\tma[make_pair(max(x,y),min(x,y))]=(dep&1)+1;\n\t\tdfs(y,dep+1);\n\t}\n}\n```\n\n## T 7\n\n首先横着和竖着是一定要切的。\n\n在选横竖中最小的一个就行了：\n\n```cpp\nfor(int i=1;i<n;i++)\n    for(int j=1;j<m;j++)\n        ans+=min(a[i],b[j]);\n```\n\n## T 8\n\n每一次单行/列修改只有对角线的真正改了。\n\n只要统计 $i=j$ 的情况就行了。\n\n```cpp\nif(i==j) ans=(ans+t)&1;\n```\n\n## T 9\n\n打表。\n\n```cpp\nif(i/1%10==4) i+=5;\nif(i/10%10==4) i+=59;\nif(i/100%10==4) i+=599;\nif(i/1000%10==4) i+=5999;\nif(i/10000%10==4) i+=59999;\nif(i/100000%10==4) i+=599999;\nif(i/1000000%10==4) i+=5999999;\nif(i/10000000%10==4) i+=59999999;\nif(i/100000000%10==4) i+=599999999;\n```\n\n统计 $i^2$，$i$，判断 $S(i^2)$ 是否等于 $S(i)^2$。\n\n```cpp\nint a=0,b=0,c=i,d=i*i;\nwhile(c>0) a+=c%10,c/=10;\na=a*a;\nwhile(d>0) b+=d%10,d/=10;\nif(a==b) ans++;\n```\n\n## T 10\n\n经过分析可得：\n\n当 $\\min\\{p_1,p_2...p_n\\} \\le 300$：\n\n就用普通的背包即可。\n\n当 $\\min\\{p_1,p_2...p_n\\} > 300$：\n\n剩下的不需要循环到 $W$，只用到 $W/\\max\\{p_1,p_2...p_n\\}$ 即可。\n\n```cpp\nfor(int i=1;i<=n;i++) mx=max(v[i],mx),mn=min(mn,v[i]);\nif(mn<=300){\n    for(int i=1;i<=n;i++)\n        for(int j=w;j>=v[i];j--) f[j]=max(f[j],f[j-v[i]]+p[i]);\n    cout<<f[w];\n}else{\n    for(int i=1;i<=n;i++)\n        for(int j=w/mx;j>=1;j--) f[j]=max(f[j],f[j-1]+p[i]);\n    cout<<f[w/mx];\n}\n```\n\n## T 11\n\n约束条件：\n\n一式：$x_a<x_b<x_c<x_d$\n\n二式：$x_b−x_a=2*(x_d−x_c)$\n\n三式：$x_b−x_a<(x_c−x_b)/3$ \n### 暴力\n\n### 枚举，$O(n^4)$\n\n枚举 $x_a,x_b,x_c,x_d$\n\n### 加一点优化，$O(n^3):$\n\n通过二式：枚举 $x_a,x_c,(x_d-x_c)$\n\n可得 $x_d=(x_d-x_c)+x_c,x_b=2*(x_d−x_c)+x_a$\n\n### 正解\n\n将二式代入三式：$2*(x_d-x_c)<(x_c-x_b)/3$\n\n移项：$6*(x_d-x_c)<x_c-x_d$\n\n得到：$6*(x_d-x_c)+k=x_c-x_d$\n\n成下图：\n\n![](https://i.loli.net/2018/08/01/5b61a76bf30ff.png)\n\n其中：$a≤1,d≤n$\n\n而 $a-d=9t+1$，\n\n所以：$9t+1≤n$, 得到 $t≤(n-1)/9$\n\n观察到在其他条件不变的情况下，\n\n只要 $c$ 和 $b$ 满足 $x_c−x_b>6t$,\n\n那么这个魔法阵就一定成立。\n\n所以当 $(a_1<a_2,b_1<b_2)$ 时，\n\n只要 $a_1$ 和 $b_2$ 能够和 $c,d$ 组成魔法阵，\n\n$a_1,b_1$ 也一定能和 $c,d$ 组成魔法阵，所以可以使用前缀和优化\n\n```cpp\nfor(int i=1;i<=n/9;i++){\n    x=1+9*i,y=0;\n    for(int j=2+9*i;j<=n;j++) y+=w[j-x]*w[j-x+i+i],d[j]+=y*w[j-i],c[j-i]+=y*w[j];\n    x=8*i+1,y=0;  \n    for(int j=n-9*i-1;j>=1;j--) y+=w[j+x]*w[j+x+i],a[j]+=y*w[j+i+i],b[j+i+i]+=y*w[j];\n}\n```\n\n## T 12\n\n难点：需要用滚动数组优化。\n\n定义 $dp_j$ 为当前猴子爬前 $j$ 棵树所消耗的最小能量值\n\n$dp_j=\\min\\{dp_j,dp_{j-1}\\}+|a_i-b_j|$\n\n```cpp\nif(j==1) dp[j]=dp[j]+abs(a[i]-b[j]);\nelse if(i==j) dp[j]=dp[j-1]+abs(a[i]-b[j]);\nelse dp[j]=min(dp[j],dp[j-1])+abs(a[i]-b[j]);\n```\n\n## T 13\n\n难点：排序。\n\n```cpp\nstruct stu{ int a,b,c; }a[100005];\nbool cmp(stu x,stu y){ return -y.b*x.c>-x.b*y.c; }\n```\n\n之后一个 01 背包就行了。\n\n\n## T 14\n\n模拟，差分。\n\n分两段，从站 $x$ 到站 $n$ 再从站 $1$ 到站 $y$。\n\n注：$s_i$ 是差分数组。\n\n```cpp\nif(b<e) s[b]+=p,s[e]-=p;\nelse s[b]+=p,s[1]+=p,s[e]-=p;\n```\n\n之后查一下 $\\left\\lceil\\dfrac{s_i}{36}\\right\\rceil$。\n\n## T 15\n\n我们发现 $S(fib(x))\\%9=fib(x)\\%9$\n\n所以 \n$(S(fib(1))+S(fib(2))+S(fib(3))+...+S(fib(n))) \\% 9=(fib(1)+fib(2)+fib(3)+...+fid(n)) \\% 9$\n代码：\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint f[1000005]={0,1,1},ans[1000005]={0,1,2},t,n;\nsigned main(){\n\tfor(int i=3;i<=1000000;i++){\n\t\tf[i]=(f[i-1]+f[i-2])%9;\n\t\tans[i]=(ans[i-1]+f[i])%9;\n\t}\n\tcin>>t;\n\twhile(t--) cin>>n,cout<<ans[n]<<'\\n';\n\treturn 0;\n}\n```\n\n## T 15\n\n1. 把  $a_i$ 排序，方便从小到大扫\n2. 用栈进行操作，如果一个位置k上面有数 $a_i=k$，那么就把所有 $=k$  的数字入栈。再把栈顶出栈，填到这个位置上，记录下 $dis=pop−push$\n3. 对 dis 进行小到大排序，把 b 数组进行大到小排序，算出答案是 $\\sum dis×b_i$\n\n## T 16\n\n因为我们要这个正整数尽量大，所以我们要把花瓣变成从 $1$ 开始的连续正整数，且长度尽量大。\n\n如果这些选中的堆拿出花瓣的和已经超过了需要的个数或选中的堆拿出花瓣的和加上未选堆花瓣的和还不够组成新堆，都是不行的。\n\n```cpp\nsort(a+1,a+n+1);\nint cnt1=0,cnt=0,v=1;\nfor(int i=1;i<=n;i++){\n\tif(a[i]<v){\n\t\tcnt1=cnt1+(a[i]-1);\n\t\tcontinue;\n\t}\n\tcnt+=(a[i]-v),v++;\n}\nif(cnt>v) cout<<v<<'\\n';\nelse if(cnt+cnt1>=v) cout<<v+1<<'\\n';\nelse cout<<v<<'\\n';\n```\n\n## T 17\n\n逆序对。\n\n## T 18\n\n模拟。\n\n## T 19\n\n求拓扑序。\n\n注意一个点不算环。\n\n## T 20\n\n双指针+前缀和。\n\n## T 21\n\n若当前这只蚂蚁左边的蚂蚁数量等于右边的蚂蚁数量，答案即为这两数之和。\n\n若左边的蚂蚁数量大于右边的蚂蚁数量时，且当前这只蚂蚁面向左，答案为右边蚂蚁数的两倍，否则多一只。\n\n若左边的蚂蚁数量小于右边的蚂蚁数量，且当前这只蚂蚁面向右，答案为左边蚂蚁数量的两倍，否则多一只。\n\n## T 22\n\n逆序对。\n\n## T 23\n\n线段树。\n\n主墓碑就是 $[1,1]$ 。\n"
  },
  {
    "title": "t1733727908IAdsvZ7bzkNsCP6w.md",
    "content": "# 题解：P10043 [CCPC 2023 北京市赛] 广播\nposted on 2024-12-09 07:05:08 | under  | [source](https://www.luogu.com.cn/blog/_post/881183)\n\n线性 DP。\n\n不难想到 $dp_{i,j}$ 代表在 $a$ 中前 $i$ 个数和 $b$ 中前 $j$ 个数满足要求。\n\n状态转移方程是：\n\n边界：\n\n1. 如果 $i=m$，$dp_{i,j+1}=\\min\\{dp_{i,j}\\}$。\n2. 如果 $j=n$，$dp_{i+1,j}=\\min\\{dp_{i,j}\\}$。\n\n之后：\n\n1. $a_{i+1}=b_{j+1}$ 或者 $a_{i+1}=1$ 或者 $b_{j+1}=1$，$dp_{i+1,j+1}=\\min\\{dp_{i,j}\\}$。\n\n最后 $dp_{i+1,j}=\\min\\{dp_{i,j}+1\\},dp_{i,j+1}=\\min\\{dp_{i,j}+1\\}$。\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t1731244063wlukteEvitWQF5xZ.md",
    "content": "# ST表\nposted on 2024-11-10 13:07:43 | under  | [source](https://www.luogu.com.cn/blog/_post/862485)\n\n## ST表\n\nST表它是解决 RMQ 问题（区间最值问题）的一种强有力的工具。\n\n时间复杂度为 $O(n \\log n+Q)$。\n\n### 实现过程\n\nPS：以下讨论的是最大值，最小值同理。\n\n建立一个 $dp$ 数组 $dp_{i,j}$ 表示从 $i$ 开始 $2^j$ 个数中的最大值。\n\n边界为 $dp_{i,0}=a_i$，即从 $i$ 点开始 $2^0$ 个数中的最大值。\n\n我们不难发现 $\\max\\{\\max\\{a_1 ... a_{\\frac{n}{2}}\\},\\max\\{a_{\\frac{n}{2}} ... a_n\\}\\}\\}=\\max\\{a_1...a_n\\}$。\n\n那状态转移方程为：\n\n$dp_{i,j}=\\max\\{dp_{i,j-1},dp_{i+2^{j-1},j-1}\\}$。\n\n其中 $dp_{i,j-1}$ 是前面一段，$dp_{i+2^{j-1},j-1}$ 是后面一段。\n\n## 求最值\n\n将该区间分成两个ST表，然后直接维护的小区间，然后二者求最值即可。\n\n就是：$\\max\\{f_{l,k},f[r−(2^k)+1][k]\\}$。\n"
  },
  {
    "title": "t1727924279k-36nRiWxC1pb6jI.md",
    "content": "# 题解：P6659 [POI 2019] Najmniejsza wspólna wielokrotność\nposted on 2024-10-03 02:57:59 | under  | [source](https://www.luogu.com.cn/blog/_post/834574)\n\n分类讨论：\n\n1. **区间长度**为 $2$：求二次方程 $x(x+1)=M$，使用二分即可。\n2. **区间长度**为 $3$：见下方。\n\n如果 $x$ 奇数：求方程 $x(x+1)(x+2)=M$。\n\n如果 $x$ 偶数：求方程 $\\Large \\frac{x(x+1)(x+2)}{2}$ $=M$。\n\n都可以用二分解决。\n\n具体解法：使用 map 存左、右端点。\n\n代码楼上楼下都已经写的很明白了，我就不赘述了。\n"
  },
  {
    "title": "t1727851287N2Y-g36wUrGE0vqC.md",
    "content": "# 题解：P10091 [ROIR 2022 Day 2] 分数排序\nposted on 2024-10-02 06:41:27 | under  | [source](https://www.luogu.com.cn/blog/_post/833847)\n\n思路：\n\n使用二分答案。\n\n二分答案分为两部分：`check` 函数和二分。\n\n二分楼上楼下都讲的很清楚了。\n\n本题解只讲 `check` 函数。\n\n首先：\n\n1. 先给 $a,b$ 数组排序。\n2. 总共有 $\\Large \\frac{a_i}{b_j}$ $>$ $\\Large \\frac{a_i}{b_{j+1}}$ 和 $\\Large \\frac{a_i}{b_j}$ $<$ $\\Large \\frac{a_i+1}{b_{j}}$。\n3. 最后双指针维护即可。\n\n下放部分代码：\n\n```cpp\nbool check(double k){\n    int j=0,sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(a[j+1]<k*b[i]&&j<n)j++;\n\t\tsum+=j;\n\t}return sum>=q;\n}\n```\n"
  },
  {
    "title": "t1727846292LcMd7s1N7nzK_esA.md",
    "content": "# 题解：P7840 「C.E.L.U-03」重构\nposted on 2024-10-02 05:18:12 | under  | [source](https://www.luogu.com.cn/blog/_post/833782)\n\n思路：\n\n注意到树有这样的性质：每个点的度数和为 $2(n−1)$。\n\n于是我们给每个点 $1$ 的度数，然后分配剩下的 $2(n-1)-n=n-2$ 个数。\n\n之后用贪心算法，对当前最优的点进行操作，对答案的为 $a(2d+1)$。\n\n维护一个优先队列，存入 $a(2d+1)$。\n\n每次取出堆顶，最后将每一个点的累加即可。\n\n代码楼上楼下都已经写的很明白了，我就不赘述了。\n"
  },
  {
    "title": "t17277688076aqL7oinMsB5x8zm.md",
    "content": "# 题解：P6123 [NEERC2016] Hard Refactoring\nposted on 2024-10-01 07:46:47 | under  | [source](https://www.luogu.com.cn/blog/_post/833128)\n\n题意：\n\n把给定的区间合并成**最简**的形式。\n\n思路：\n\n可以用**贪心**的思想解此题：\n\n1. 将所有给出的区间按小值的值从小到大排序。\n2. 如果一个区间可以与上一个区间合并的，合并区间。\n\n特判：\n1. 如一个区间为 $[-2^{15},2^{15}]$ 则输出 `true`。\n2. 如没有合法的区间（即第一个数 $>$ 第一个数）则输出 `false`。\n3. 输出时，省略补全的数字。\n\n代码楼上楼下都已经写的很明白了，我就不赘述了。\n"
  },
  {
    "title": "t1727356880v1iWNgE-FpEckyYR.md",
    "content": "# 康托展开\nposted on 2024-09-26 13:21:20 | under  | [source](https://www.luogu.com.cn/blog/_post/830491)\n\n$a_n×(n−1)!+a_{n−1}×(n−2)!+⋯+a_2​ ×1!+a_1×0! = \\sum^n_{i=1}a_i\\times(n-i)!$\n\n$a_i$ 是**比当前位小，且没有在之前位出现过的**元素个数\n"
  },
  {
    "title": "t1726834226uQii_kFJ1e7DcB0q.md",
    "content": "# 排序的稳定性\nposted on 2024-09-20 12:10:26 | under  | [source](https://www.luogu.com.cn/blog/_post/827372)\n\n# 排序的稳定性\n\n\n\n|排序算法|平均时间复杂度|最好时间复杂度|最坏时间复杂度|空间复杂度|是否稳定|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|冒泡排序|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|$T$\n|选择排序|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|$F$\n|插入排序|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|$T$\n|归并排序|$O(n~log~n)$|$O(n~log~n)$|$O(n~log~n)$|$O(n)$|$T$\n|快速排序|$O(n~log~n)$|$O(n~log~n)$|$O(n^2)$|$O(log~n)$|$F$\n|堆排序|$O(n~log~n)$|$O(n~log~n)$|$O(n~log~n)$|$O(1)$|$F$\n|希尔排序|$O(n~log~n)$|$O(n)$|$O(n^2)$|$O(1)$|$F$\n|计数排序|$O(n+k)$|$O(n+k)$|$O(n+k)$|$O(n+k)$|$T$\n|基数排序|$O(n \\times m)$|$O(n \\times m)$|$O(n \\times m)$|$O(m)$|$T$\n\n# 排序的描述：\n\n## 一.冒泡排序\n基本思想：\n\n两个数比较大小，较大的数下沉，较小的数冒起来。\n\n## 二.选择排序\n基本思想：\n\n在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；\n\n第二次遍历n-2个数，找到最小的数值与第二个元素交换；\n第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。\n\n## 三.插入排序\n基本思想：\n\n在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。\n\n## 四.希尔排序\n基本思想：\n\n在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。\n\n然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。\n\n## 五.快速排序（分治思想）\n基本思想：\n\n先从数列中取出一个数作为key值；\n\n将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；\n\n对左右两个小数列重复第二步，直至各区间只有1个数。\n\n## 六.归并排序\n基本思想：\n\n归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。\n\n首先考虑下如何将2个有序数列合并。这个非常简单，只要从比较2个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。\n\n# 排序稳定性\n\n稳定排序有：插入排序、冒泡排序、归并排序。\n\n不稳定排序：希尔排序、快速排序、选择排序、堆排序。\n\n口诀，不稳定的排序：快（快排）些（希尔）选（选择）一堆（堆排）。\n"
  },
  {
    "title": "t17265520896iPEBPSpvCoWRVa3.md",
    "content": "# 哈夫曼树与哈夫曼编码\nposted on 2024-09-17 05:48:09 | under  | [source](https://www.luogu.com.cn/blog/_post/825859)\n\n# 哈夫曼树：\n\n哈夫曼树可由如下方式构造：\n1. 由给定的 $n$ 个权值构造 $n$ 棵仅含有一个根结点的二叉树，记作集合 $F$。\n2. 从集合 $F$ 中选取根结点权值最小的两棵二叉树 $T1$，$T2$ 作为左右子树构造新的二叉树 $T3$，新二叉树的根结点为 $T1$，$T2$ 根结点的权值和。\n3. 从集合 $F$ 中删除 $T1$，$T2$，将 $T3$ 加入 $F$ 中。\n4. 直到 $F$ 中只剩下唯一一棵二叉树为止，这棵树即为哈夫曼树。\n\n建树：\n\n|字符|频率|编码|长度|\n|:-:|:-:|:-:|:-:|\n|A|35|11|2|\n|B|25|00|2|\n|C|15|01|2|\n|D|15|101|3|\n|E|10|100|3|\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/avfymu9b.png)\n\n# 哈夫曼编码：\n\n哈夫曼编码根据字符在数据中出现的频率来分配不同长度的编码，频率**高**的字符分配较**短**的编码，频率**低**的字符分配较**长**的编码，从而实现压缩数据的目的，是一种**贪心思想**。\n\n哈夫曼编码是一种**前缀编码**，即任一编码都不是其他任何一个编码的前缀。哈夫曼编码即为前缀编码中**最短**的。\n\n## 带权路径长度(WPL)。\n\nWPL 是每个编码的长度 $\\times$ 频率。\n\n|字符|频率|编码|长度|WPL(单个的)|\n|:-:|:-:|:-:|:-:|:-:|\n|A|35|11|2|70|\n|B|25|00|2|50|\n|C|15|01|2|30|\n|D|15|101|3|45|\n|E|10|100|3|30|\n\nWPL（总共的）$=70+50+30+45+30=225$。\n"
  },
  {
    "title": "t1726451628SbBTtucyHPGCvQKh.md",
    "content": "# 题解：CF73C LionAge II\nposted on 2024-09-16 01:53:48 | under  | [source](https://www.luogu.com.cn/blog/_post/825265)\n\n思路：\n\n$dp_{i,j,c}$ 它表示在前 $i$ 个字符中使用了 $j$ 次更改操作。\n\n并且最后一个字符是 $c$ 的情况下所能达到的最大美丽度。\n\n状态转移方程：\n\n如果 $m=s[i-1]- \\texttt a $：$ dp_{i,j,m}=\\max\\{dp_{i,j,m},dp_{i-1,j,q}+c_{q,m}\\}$\n\n如果 $m \\ne s[i-1]-\\texttt a$：$dp_{i,j,m}=\\max\\{dp_{i,j,m},dp_{i-1,j-1,q}+c_{q,m}\\}$。\n\n代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint c[26][26],dp[105][105][26],k,n,p,ans=INT_MIN;\nstring s;\nchar x,y;\nsigned main() {\n\tcin>>s>>k>>n;\n    for(int i=1;i<=n;i++){\n\t\tcin>>x>>y>>p;\n\t\tc[x-'a'][y-'a']=p;\n\t}\n\tfor(int i=1;i<=s.size();i++)\n\t\tfor(int m=0;m<26;m++) dp[i][0][m]=-1e9;\n\tdp[1][0][s[0]-'a']=0;\n\tfor(int i=2;i<=s.size();i++)\n\t\tfor(int j=0;j<=k;j++)\n\t\t\tfor(int m=0;m<26;m++)\n\t\t\t\tif(m==s[i-1]-'a')\n\t\t\t\t\tfor(int q=0;q<26;q++) dp[i][j][m]=max(dp[i][j][m],dp[i-1][j][q]+c[q][m]);\t\n\t\t\t\telse if(j)\n\t\t\t\t\tfor(int q=0;q<26;q++) dp[i][j][m]=max(dp[i][j][m],dp[i-1][j-1][q]+c[q][m]);\n    for(int m=0;m<26;m++) ans=max(ans,dp[s.size()][k][m]);\n    cout<<ans<<endl;\n    return 0;\n}\n```\n"
  },
  {
    "title": "t1726390602_K85C6hFsQ7j5U-i.md",
    "content": "# 题解：CF992B Nastya Studies Informatics\nposted on 2024-09-15 08:56:42 | under  | [source](https://www.luogu.com.cn/blog/_post/824943)\n\n首先，我们知道 $\\operatorname{lcm}(x,y) \\times \\gcd(x,y)=a \\times b$。\n\n之后，就可以构造了：\n\n因为 $a$ 一定要整除 $\\operatorname{lcm}(a,b)$。\n\n再枚举 $\\operatorname{lcm}(a,b)$ 的因数。\n\n每个因数就判断一下，加入答案。\n\n判断的代码：\n\n```cpp\nbool check(int a){\n\tint b=x*y/a;\n    return !(a<l||a>r||b<l||b>r||__gcd(a,b)!=x);\n}\n```\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t1726379940EuVEimEvw3qekj9V.md",
    "content": "# 题解：CF1526C1 Potions (Easy Version)\nposted on 2024-09-15 05:59:00 | under  | [source](https://www.luogu.com.cn/blog/_post/824812)\n\n思路 1：\n\n使用动态规划算法，$f_i$ 是表示喝 $i$ 瓶药的最大值。\n\n可以得出：$f_j=\\max(f_j,f_{j-1}+a_j)$。\n\n关键代码：\n\n```cpp\nfor(int i=1;i<=n;i++)\n    for(int j=i;j;j--)\n        if(f[j-1]+a[i]>=0)\n             f[j]=max(f[j],f[j-1]+a[i]);\n```\n\n时间复杂度：$O(n^2)$。\n\n思路 2：\n\n使用贪心算法+优先队列。\n\n\n先拼劲全力去喝，如果在这道题中喝药喝死了，我们就要将他把药吐出来。\n\n关键代码：\n\n\n```cpp\nfor(int i=1;i<=n;i++){\n    sum+=f[i],q.push(-f[i]);\n    if(sum<0){\n        p=q.top(),q.pop();\n        p=-p,sum-=p,t++;\n    }\n}\n```\n\n时间复杂度：$O(n \\log_2 n)$。\n"
  },
  {
    "title": "t1726309274lplgiqLE6AXuc2yD.md",
    "content": "# 题解：CF1081C Colorful Bricks\nposted on 2024-09-14 10:21:14 | under  | [source](https://www.luogu.com.cn/blog/_post/824349)\n\n思路：\n\n此题是一道组合题。\n\n首先，利用插板法，在 $n-1$ 个空里选 $k$ 个空，有 $C_{n-1}^k$。\n\n之后，整合之后会有 $m+1$ 个整体，第一个整体是 $m$，剩下都是 $m-1$ 次，答案是 $m(m+1)^k$。\n\n最后，答案就是 $C_{n-1}^k \\times m(m+1)^k$。\n\n但如果你直接用 c++ 自带的 pow 函数，你就会错。\n\n所以，你就要用手写的快速幂：\n\n```cpp\nint pw(int a,int b,int p){ // p 是模数\n    int ans=1,bs=a;\n    while(b){\n        if(b&1) ans=ans*bs%p;\n        bs=bs*bs%p;\n        b>>=1;\n    }\n    return ans;\n}\n```\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t172614142453D4RjeNpL1Pbwg7.md",
    "content": "# 题解：SP2884 MARTIAN - Martian Mining\nposted on 2024-09-12 11:43:44 | under  | [source](https://www.luogu.com.cn/blog/_post/823504)\n\n思路：\n\n我们发现，如果要采 $(a,b)$ 上的矿，那么运输路上（即 $(a,b-1),(a,b-2)...(a,1)$ 或$(a-1,b),(a-2,b)...(1,b)$）的这种矿物都要全采。\n\n得知这一点后，我们考虑是用动归，定义 $f_{i,j}$ 是为在以 $(i,j)$ 为右下角的子矩阵中的最大采矿量。\n\n维护两个前缀和数组 $a,b$ (具体是什么见代码），$f_{i,j}=\\max(f_{i-1,j}+a_{i,j},f_{i,j-1}+b_{i,j})$。\n\n代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,a[505][505],b[505][505],f[505][505];\nsigned main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tcin>>a[i][j],a[i][j]+=a[i][j-1]; //前缀和数组 a\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tcin>>b[i][j],b[i][j]+=b[i-1][j]; //前缀和数组 b\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tf[i][j]=max(f[i-1][j]+a[i][j],f[i][j-1]+b[i][j]);\n\t\tcout<<f[n][m]<<'\\n';\n\t}\n\treturn 0;\n}\n```\n"
  },
  {
    "title": "t172614135996-ryhelI81xlc80.md",
    "content": "# 题解：UVA1366 Martian Mining\nposted on 2024-09-12 11:42:39 | under  | [source](https://www.luogu.com.cn/blog/_post/823502)\n\n前言：\n\n看到楼上楼下基本上都用三维的 dp 数组，我来介绍一种用二维的 dp 数组的做法。\n\n思路：\n\n我们发现，如果要采 $(a,b)$ 上的矿，那么运输路上（即 $(a,b-1),(a,b-2)...(a,1)$ 或$(a-1,b),(a-2,b)...(1,b)$）的这种矿物都要全采。\n\n得知这一点后，我们考虑是用动归，定义 $f_{i,j}$ 为在以 $(i,j)$ 为右下角的子矩阵中的最大采矿量。\n\n维护两个前缀和数组 $a,b$ (具体是什么见代码），$f_{i,j}=\\max(f_{i-1,j}+a_{i,j},f_{i,j-1}+b_{i,j})$。\n\n代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,a[505][505],b[505][505],f[505][505];\nsigned main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tcin>>a[i][j],a[i][j]+=a[i][j-1]; //前缀和数组 a\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tcin>>b[i][j],b[i][j]+=b[i-1][j]; //前缀和数组 b\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tf[i][j]=max(f[i-1][j]+a[i][j],f[i][j-1]+b[i][j]);\n\t\tcout<<f[n][m]<<'\\n';\n\t}\n\treturn 0;\n}\n```\n"
  },
  {
    "title": "t1726054895cU9YeoSFgVtjBr30.md",
    "content": "# 题解：CF1109A Sasha and a Bit of Relax\nposted on 2024-09-11 11:41:35 | under  | [source](https://www.luogu.com.cn/blog/_post/823057)\n\n翻译：\n\n求有多少个区间内的数异或值为 $0$。\n\n思路：\n\n处理出前缀异或数组 $q$。\n\n如果 $q_i=q_j$，则区间是存在的。\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t1725801667fTgOlBXw2NR1GyrK.md",
    "content": "# 题解：CF1598D Training Session\nposted on 2024-09-08 13:21:07 | under  | [source](https://www.luogu.com.cn/blog/_post/821822)\n\n题目翻译：\n\n给定 $n$ 个互不相同二元组，现在要从其中选出三个二元组，使得这三个二元组的的前一项互不相同或后一项互不相同。求有几种方案。\n\n思路：\n\n正难则反，先算总数：有 $\\Large\\frac{n \\times (n-1) \\times (n-2)}{6}$ 种情况。\n\n不满足的情况是没有一个二元组与另一个二元组元素两两不相同（同一个元素）。\n\n也就是就是一个二元组与另一个二元组元素至少一个相同（也是同一个元素）。\n\n考虑用桶记录，$x_i$ 代表 $a_i$ 的出现个数，$y_i$ 代表 $b_i$ 的出现个数。\n\n第一组固定，第二组有 $x_{a_i}-1$ 种，第三组有 $y_{b_i}-1$ 种。\n\n一共有 $(x_{a_i}-1) \\times (y_{b_i}-1)$。\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t1725760172Vu8YYSwP8O4u705N.md",
    "content": "# 题解：P11020 「LAOI-6」Radiation\nposted on 2024-09-08 01:49:32 | under  | [source](https://www.luogu.com.cn/blog/_post/821226)\n\n思路：\n1. 我们发现斜线上必须来有一块石子，能使小 U 发射一次宇宙射线。\n2. 斜线上有几个棋子呢？ 有 $\\min(n,m,k)$ 个。\n3. 剩下的棋子随便放就行了\n\n温馨提示：\n1. 多测不清空，爆零两行泪！！！\n2. 不要用 memset ！！！\n\ncode:\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint t,n,m,k,a[2005][2005];\nsigned main(){\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m>>k;\n//\t\tmemset(a,0,sizeof(a)) 慎用！！！ \n\t\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) a[i][j]=0; //初始化\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tif(i==j&&k) a[i][j]=1,k--; //放斜线\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(a[i][j]) cout<<'S';\n\t\t\t\telse if(k) cout<<'S',k--; //随便放\n\t\t\t\telse cout<<'.';\n\t\t\t}\n\t\t\tcout<<'\\n';\n\t\t}\n\t}\n}\n```\n"
  },
  {
    "title": "t1725757964x_hc7Y3muKvR8Nxe.md",
    "content": "# 题解：P11019 「LAOI-6」[太阳]] 请使用最新版手机 QQ 体验新功能\nposted on 2024-09-08 01:12:44 | under  | [source](https://www.luogu.com.cn/blog/_post/821177)\n\n我们考虑直接模拟：\n\n1. 找到 `[` 和 `]` ，确定左端点 $l$ 和右端点 $r$。\n2. 我们可已发现汉字的首字母一定是大写的，所以只要在 $l$ 到 $r$ 中找大写字母，转成小写就行了。\n\ncode:\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint l,r; //左右端点 \nstring s;\nsigned main(){\n\tcin>>s;\n\tl=s.find('['),r=s.find(']'); //赋值 \n\tcout<<'/';\n\tfor(int i=l;i<=r;i++)\n\t\tif(s[i]>='A'&&s[i]<='Z') \n\t\t\tcout<<char(s[i]-'A'+'a'); //大写转小写 \n}\n```\n"
  },
  {
    "title": "t17233568449YYttpmnqEKXUt2S.md",
    "content": "# P1057 [NOIP2008 普及组] 传球游戏\nposted on 2024-08-11 06:14:04 | under  | [source](https://www.luogu.com.cn/blog/_post/801747)\n\n## 题意：\n$n$个同学围成一个圆圈进行传球游戏，一个同学传球时只能传给左右的同学，传$m$次最终回到第一个人手里，问你有多少种情况？\n\n我们可以发现，任何一个位置都只能从左边和右边传过来，那么他只能从他左边和他右边的同学手上接到球\n\n## 思路\n\n我们再整理一下原问题：\n>从$1$开始传球，第$m$步回到$1$号的情况数\n\n得出子问题：\n从1开始传球第i步到达j号的情况数\n\n## 我的解法：DP\n\n$f_{i,j}$表示第i次传球后在j位置的情况数\n\n得到状态转移方程：\n\n如果 $j$==$n$ ：$f_{i,j}=f_{i-1,1}$+$f_{i-1,n-1}$\n\n如果 $j$==_1_ ：$f_{i,j}=f_{i-1,n}$+$f_{i-1,2}$\n\n如果 $j$<$n$ 并且 $j$>_1_：$f_{i,j}=f_{i-1,j-1}$+$f_{i-1,j}$+${_1}$\n\n答案就是 $f_{m,1}$\n\n表格：\n\n![alt](https://uploadfiles.nowcoder.com/images/20240704/738894346_1720086561372/AF9ED552F355DC4F82B66A73253CDB8F)\n\n\n\n### CODE:\n\n``` cpp\n#include<bits/stdc++.h>\n#define oo INT_MAX\n#define int long long\nusing namespace std;\nint n,m,f[35][35];\nsigned main() {\n\tcin>>n>>m;\n\tf[0][1]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==1) f[i][j]=f[i-1][2]+f[i-1][n];\n\t\t\telse if(j==n) f[i][j]=f[i-1][1]+f[i-1][n-1];\n\t\t\telse f[i][j]=f[i-1][j-1]+f[i-1][j+1];\n\t\t}\n\t}\n\tcout<<f[m][1];\n}\n```\n"
  },
  {
    "title": "p1572-post.md",
    "content": "# P1572 计算分数\nposted on 2024-02-23 13:18:02 | under  | [source](https://www.luogu.com.cn/blog/_post/713430)\n\n如果过了就是本蒟蒻的第一篇题解~~求过~~。\n\n[这道题](https://www.luogu.com.cn/problem/P1572)是一道**模拟题！！**\n\nhack数据:\n\n   1. 用`cin`输入。\n\n   2. 如果分母为$0$，则输出分子。\n\n不然会[这样](https://www.luogu.com.cn/record/147674005)的。\n\n------------\n\n\n代码的整体思路是：\n\n   1. 维护$ansa$和$ansb$，代表分子和分母。\n         \n   2. 处理负数的情况，分母和分子同乘以$-1$。\n      \n   3. 通分：`__gcd`是用来求最大公约数的，过程见代码。\n            \n   4. 输出：如果分母为$1$，只输出分母。\n            \n我们要注意每一次处理完都通分，不然会[ 爆 int ](https://www.luogu.com.cn/record/148205954)的。\n\n本程序已经过测试，保证能通过hack数据。\n\n------------\n\n \n\n代码:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint lcm,a1,b1,i;\nlong long ansa,ansb,a,b; // ansa 是分子， ansb 是分母\nchar s,tmp;\nint main(){\n    cin>>a>>tmp>>b;\n    while(cin>>s>>a1>>tmp>>b1){ //while输入，注意用 cin 输入 \n        i++; //记录输入次数\n        ansb=b1*b;\n        //按加减记录 ansa ，ansa 是 a*b1 和 a1*b 的和或差 \n        if(s=='+') ansa=a*b1+a1*b; \n        if(s=='-') ansa=a*b1-a1*b;\n        if(ansb<0ll){ //负数处理 \n            ansa*=-1ll;\n            ansb*=-1ll;\n        }\n        int gcdd=__gcd(ansa,ansb); //通分 \n        ansa=ansa/gcdd;\n        ansb=ansb/gcdd;\n        a=ansa;\n        b=ansb;\n    }\n    if(i==0){ //如果只有一个算式话，通分并输出 \n        ansa=a;\n        ansb=b;\n        int gcdd=__gcd(ansa,ansb);\n        ansa=ansa/gcdd;\n        ansb=ansb/gcdd;\n        cout<<ansa<<'/'<<ansb;\n        return 0;\n    }\n    if(ansb<0ll){ //负数处理 \n        ansa*=-1ll;\n        ansb*=-1ll;\n    }\n    if(ansb!=1) cout<<ansa<<'/'<<ansb; //如果分母不为 1 ，输出分式 \n    else cout<<ansa; //如果分母为 1 ，输出分子 \n    return 0;\n}\n```\n\n\n~~最后不要脸的求个赞~~\n"
  },
  {
    "title": "t1726048072xTY8flVlNHEpPPl2.md",
    "content": "# 题解：P10928 走廊泼水节\nposted on 2024-09-11 09:47:52 | under  | [source](https://www.luogu.com.cn/blog/_post/823005)\n\n回顾 kruskal：\n\n取边权最小的一条边，若两个点在不同连通块（并查集），则连边合并。\n\n我们把以上规则改一下：\n\n如果点 $A$ 的老大的小弟数<点 $B$ 的老大的小弟数，$A$ 成为 $B$ 小弟。\n\n反之，$B$ 成为 $A$ 小弟。\n\n我们定义 $s_i$ 是点 $i$ 的老大的小弟数，$w$ 是 $a$ 到 $b$ 的边权。\n\n贡献和为：$(s_A×s_B−1) \\times (w+1)$。\n\n代码楼上楼下都已经写的很明白了，我就不在赘述了。\n"
  },
  {
    "title": "t1723690743QShE5u-0bOh_A6Lb.md",
    "content": "# 题解：CF333B Chips\nposted on 2024-08-15 02:59:03 | under  | [source](https://www.luogu.com.cn/blog/_post/805308)\n\n[原题](https://codeforces.com/problemset/problem/333/B)[传送门](https://www.luogu.com.cn/problem/CF333B)\n\n## 题目大意：\n\n有一个 $n \\times n$ 的棋盘，$m$ 个格子是障碍物，然后移动芯片使它们返回到初始对边位置，不能经过障碍物、重叠或交换位置。问最多可以放置多少个芯片完成游戏。\n\n## 思路：\n本题直接按题意**模拟**即可：\n\n1. **使用桶记录障碍**，$a_i$ 代表第 $i$ 行的芯片个数，同理 $b_i$ 代表第 $i$ 列的芯片个数。\n\n2. 如果第 $i$ 行或第 $j$ 没有芯片，$cnt+1$。\n\n3. 如果相遇，就是 $n$ 为奇数且中间行且列有值，$cnt-1$。\n\n\n下面是样例 $3$ 的解释：\n\n||列1|列2|列3|列4|\n|:-:|:-:|:-:|:-:|:-:|\n|**行1**|无芯片|可放芯片|可放芯片|无芯片|\n|**行2**|**放芯片**|______|______|**放芯片**|\n|**行3**|障碍物|障碍物|障碍物|可放芯片|\n|**行4**|无芯片|可放芯片|可放芯片|无芯片|\n\n行2的两个芯片可以连通，$cnt=1$。\n\n没有相遇情况，输出 $1$。\n\n## 上代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,x,y,a[100005],b[100005],cnt;\nint main(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++){\n        cin>>x>>y;\n        a[x]++,b[y]++;\n        //a[i] 是行，b[i] 是列。\n    }\n    for(int i=2;i<n;i++) cnt+=(!a[i])+(!b[i]); //不懂？看下面↓\n    // a[i] 如果是空的，cnt+1。\n    // b[i] 如果是空的，cnt+1。\n    cout<<cnt-((n%2==1)&&!a[n/2+1]&&!b[n/2+1]);\n    //如果相遇答案 -1。\n    return 0;\n}\n```\n括号的意思：如果括号里面的的表达式为 $true$ ，返回 $1$ ，否则返回 $0$。\n"
  }
]